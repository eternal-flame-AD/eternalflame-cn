<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on Eternal-flame-AD</title>
    <link>/categories/java/</link>
    <description>Recent content in Java on Eternal-flame-AD</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 27 Mar 2018 03:24:02 +0000</lastBuildDate>
    
	<atom:link href="/categories/java/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>【AP CSA学习心得】（2）抽象和继承</title>
      <link>/blog/2018/03/ap-csa%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%972%E6%8A%BD%E8%B1%A1%E5%92%8C%E7%BB%A7%E6%89%BF/</link>
      <pubDate>Tue, 27 Mar 2018 03:24:02 +0000</pubDate>
      
      <guid>/blog/2018/03/ap-csa%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%972%E6%8A%BD%E8%B1%A1%E5%92%8C%E7%BB%A7%E6%89%BF/</guid>
      <description>抽象和继承一直是AP CSA考察的重点，在这里先码一段介绍整理一下（知识点只涉及了AP涉及到的部分，求大佬轻喷）
&amp;nbsp;
在定义类时，我们可以加入abstract关键字来定义一个抽象类：
abstract class book { public static String material=&amp;#34;paper&amp;#34;; public String ISBN; public String title; public int pagenow; protected book() { //constructor dont have return types  this.pagenow=1; } public void flip_page() { pagenow++; System.out.println(&amp;#34;Flipped to page &amp;#34;+pagenow); } } 抽象类和class很像，只是不能实例化，因此这个book现在只能读取book.material=&amp;#8221;paper&amp;#8221;
抽象类可以被继承成更加具体的类：
class AP_Princeton extends book { public String ISBN=&amp;#34;978-1-101-91988-0&amp;#34;; public String title=&amp;#34;Cracking the AP CSA Exam&amp;#34;; private static String Customer_review; public void flip_page() { System.out.println(&amp;#34;FLipping page of:&amp;#34;+this.</description>
    </item>
    
    <item>
      <title>【AP CSA学习心得】（1）String的比较</title>
      <link>/blog/2018/03/ap-csa%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%971string%E7%9A%84%E6%AF%94%E8%BE%83/</link>
      <pubDate>Mon, 26 Mar 2018 15:47:40 +0000</pubDate>
      
      <guid>/blog/2018/03/ap-csa%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%971string%E7%9A%84%E6%AF%94%E8%BE%83/</guid>
      <description>今天学习AP CSA时出现了一个问题：
package loops; import java.util.Scanner; public class WhileLoop { public static void main(String[] args) { Scanner input=new Scanner(System.in); String password=&amp;#34;&amp;#34;; while (password!=&amp;#34;PASSWORD&amp;#34;) { //WARNING: password!=&amp;#34;PASSWORD&amp;#34; is NOT going to work! This is causing an infinite loop  System.out.print(&amp;#34;Password please:&amp;#34;); password=input.next(); //password=&amp;#34;PASSWORD&amp;#34;; //Uncomment this and the while loop will end  System.out.println(password.length()); //8  System.out.println(&amp;#34;PASSWORD&amp;#34;.length()); //8  System.out.println(password==&amp;#34;PASSWORD&amp;#34;); //always false  } System.out.println(&amp;#34;OK.&amp;#34;); } } 如上的代码，不论输入的字符串是否正确，循环均会一直进行，找了很久没有找到原因，后来发现是input.next()出来的String对象和直接&amp;#8221;PASSWORD&amp;#8221;出来的对象不等，应当使用String.equals()方法
然而，int等其它类型却没有这个问题
package loops; import java.</description>
    </item>
    
  </channel>
</rss>