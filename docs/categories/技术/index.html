<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">

    

    <base href="https://eternalflame.cn/">
    <title>技术 | eternal-flame-AD</title>
    <link rel="canonical" href="https://eternalflame.cn/categories/%E6%8A%80%E6%9C%AF/">
    <link href="https://eternalflame.cn/categories/%E6%8A%80%E6%9C%AF/index.xml" rel="alternate" type="application/rss+xml" title="技术" />

    
<script src="https://cdn.bootcss.com/jquery/3.2.1/jquery.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN" crossorigin="anonymous"></script>
<script src="https://cdn.bootcss.com/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"></script>
<script src="https://cdn.bootcss.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>




<link rel="stylesheet" href="https://eternalflame.cn/style.css" />



<script src="/js/anime.min.js"></script>
<script async src="/js/fireworks.js"></script>

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous">
</head>
<body lang="en">
    <nav class="navbar navbar-default navbar-expand-lg navbar-light bg-light">
    
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#nav-main" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
    </button>
    <div class="collapse navbar-collapse" id="nav-main">
        <ul class="navbar-nav mr-auto">
            <li class="nav-item"><a href="/" class="nav-link">Home</a></li>
            <li class="nav-item"><a href="/blog/" class="nav-link">Blog</a></li>
            <li class="nav-item"><a href="https://github.com/eternal-flame-AD" class="nav-link">Github</a></li>
            <li class="nav-item"><a href="https://connect.garmin.com/modern/profile/67225a8f-1f19-491b-ae65-274a76fe0ba1" class="nav-link">Garmin Connect</a></li>
            <li class="nav-item"><a href="https://keybase.io/eternal_flame" class="nav-link">Keybase</a></li>
        </ul>
        <button class="btn btn-primary my-2 my-sm-0" onClick="javascript::window.location.href='https://github.com/eternal-flame-AD'"><i class="fab fa-github"></i>Follow me on Github</button>
    </div>
</nav>
    <div class="container">
        <div class="jumbotron">
            <h1 class="display-4">技术</h1>
            <p class="text-muted">This is a list for articles of category: 技术</p>
        </div>
        
            <div class="list-item ">
    <h3 class="list-title"><a href="https://eternalflame.cn/blog/2018/10/%E4%BD%BF%E7%94%A8python%E6%8A%93%E5%8F%96rejet%E4%BD%9C%E5%93%81%E5%AE%98%E5%8D%9A/">使用Python抓取rejet作品官博</a></h3>
    <i class="text-muted"><i class="fas fa-user"></i>Eternal-flame-AD</i> <br />
    <i class="text-muted"><i class="fas fa-clock"></i>Fri, Oct 5, 2018</i> <br />
    <i class="text-muted"><i class="fas fa-shapes"></i><a href="/categories/python">Python&nbsp;</a><a href="/categories/%e6%8a%80%e6%9c%af">技术&nbsp;</a></i> <br />
    
    <i class="text-muted"><i class="fas fa-comment"></i><a href="https://eternalflame.cn/blog/2018/10/%E4%BD%BF%E7%94%A8python%E6%8A%93%E5%8F%96rejet%E4%BD%9C%E5%93%81%E5%AE%98%E5%8D%9A/#disqus_thread">Comments</a></i> <br />
    
    <hr />
    
    <p class="text-muted">
        
            今天又被安利了R社的另一个IP——「幽幻ロマンチカ」，还是和剑君一样养眼的画风～～ 不过小透明不会日语再也啃不动了QWQ
于是打算搜刮一波图来舔，打开官博之后发现竟然和剑君的是一个套路（也许R社太懒两个作品的官博用的就是同一套CMS换了个主题hhhh）：
「幽幻ロマンチカ」的URL前缀是：
http://rejetweb.jp/yuroma/blog/
剑君的是：
http://rejetweb.jp/kengakimi/blog/
所以就翻出了几个月前自己用来下剑君官博的图的脚本，把前缀的配置提出来就可以支持这个作品了～
代码传到了Github Gist上，完全使用正则表达式来匹配，因为是一次性的活所以小透明就怎么方便怎么来了～
 &nbsp;
        
    </p>
</div>
        
            <div class="list-item ">
    <h3 class="list-title"><a href="https://eternalflame.cn/blog/2018/09/%E9%80%9A%E8%BF%87https%E4%B8%AD%E9%97%B4%E4%BA%BA%E7%BB%95%E8%BF%87sni-based-censorship/">通过HTTPS中间人绕过SNI-based censorship</a></h3>
    <i class="text-muted"><i class="fas fa-user"></i>Eternal-flame-AD</i> <br />
    <i class="text-muted"><i class="fas fa-clock"></i>Wed, Sep 19, 2018</i> <br />
    <i class="text-muted"><i class="fas fa-shapes"></i><a href="/categories/golang">Golang&nbsp;</a><a href="/categories/%e6%8a%80%e6%9c%af">技术&nbsp;</a></i> <br />
    <i class="text-muted"><i class="fas fa-tags"></i><a href="/tags/gfw">GFW&nbsp;</a><a href="/tags/golang">Golang&nbsp;</a><a href="/tags/http%e4%bb%a3%e7%90%86">HTTP代理&nbsp;</a><a href="/tags/sni">SNI&nbsp;</a><a href="/tags/tls">TLS&nbsp;</a></i>
    <i class="text-muted"><i class="fas fa-comment"></i><a href="https://eternalflame.cn/blog/2018/09/%E9%80%9A%E8%BF%87https%E4%B8%AD%E9%97%B4%E4%BA%BA%E7%BB%95%E8%BF%87sni-based-censorship/#disqus_thread">Comments</a></i> <br />
    
    <hr />
    
    <p class="text-muted">
        
            最近墙似乎又升级了，增加了基于SNI的检测，导致P站不翻墙完全不能访问，症状是Firefox建立的所有TCP链接均在TLS Client Hello发送后被Reset，之前写的mkhosts工具也不好使了：因为直接建立TCP是能通的，但是真正访问目标网站的时候因为要发送明文的SNI，因此被拦截。
本来这么一想解决方法就是简单粗暴——别发SNI不就好了，但后来发现并不简单，没有哪个浏览器允许用户使用任何方式直接调整TLS握手的时候的参数的。
看来这样，完全在浏览器里解决问题是不太现实了，我本来想着是不是可以把握手的时候浏览器发送的SNI修改一下，但每次浏览器都无法建立TLS链接，使用wireshark抓包发现在Handshake Finished阶段对端发出Alert Decryption Error，无法完成握手。查询rfc发现自己Too Young Too Simple，Handshake Finished阶段服务器端要签名整个握手阶段报文的hash来确定握手没有被修改，所以这条路又凉了。
最后只好退一步编写一个中间人来截获浏览器的TLS连接，再向目标服务器建立另一个修改过的链接，然后把两边的TLS通道相互copy一下。
上一个演示代码（Github Gist 国内现在好像也凉了 可能是因为上面有一些你懂得证据吧），利用elazarl/goproxy 来建立本地HTTP代理，截获其中的CONNECT请求（浏览器会通过HTTP CONNECT动词尝试经过代理服务器建立和对端服务器的连接，我们在这里不要直接链接对方服务器而是自己签发对方域名的证书，然后做一次修改的握手，复制两边TLS通道内传递的消息）修改的握手部分主要要注意ServerName不要传递，跳过默认证书验证（因为那是基于ServerName的，你没有给ServerName是过不了的），使用内置的crypto/x509写一个自定义的验证函数（再次吐槽 node里面只要checkServerIdentity: (host, cert)=&gt;tls.checkServerIdentity(realhost, cert)一句话就好了，go写了这么长hhhh）：
 安装ca证书后，编译运行代码，浏览器设置http代理http://127.0.0.1:8080/ （HTTPS也要走这个代理）即可
&nbsp;
有个朋友当时跟小透明说要不要把这个完善一下做成项目，小透明后来想了一下觉得还是不了，一是因为SNI审查不会是常态，应该会过去的，二是整个思路其实很清晰很简单也不复杂，程序员应该很容易就能写出来而且更加符合自己的需求，而对于普通人这些方法想比××上网来的太不稳定太复杂了，也没有太大价值。就当作一次尝试啦～
更新：已经写成项目了，在这里
        
    </p>
</div>
        
            <div class="list-item ">
    <h3 class="list-title"><a href="https://eternalflame.cn/blog/2018/07/%E5%9C%A8openwrt-lede%E4%B8%8A%E9%83%A8%E7%BD%B2dnscrypt-proxy%E5%BC%BA%E5%8C%96%E5%AE%B6%E5%BA%AD%E7%BD%91%E7%BB%9Cdns%E5%AE%89%E5%85%A8/">在openwrt/lede上部署dnscrypt-proxy，强化家庭网络dns安全</a></h3>
    <i class="text-muted"><i class="fas fa-user"></i>Eternal-flame-AD</i> <br />
    <i class="text-muted"><i class="fas fa-clock"></i>Tue, Jul 24, 2018</i> <br />
    <i class="text-muted"><i class="fas fa-shapes"></i><a href="/categories/openwrt%e5%ba%94%e7%94%a8">Openwrt应用&nbsp;</a><a href="/categories/%e6%8a%80%e6%9c%af">技术&nbsp;</a></i> <br />
    
    <i class="text-muted"><i class="fas fa-comment"></i><a href="https://eternalflame.cn/blog/2018/07/%E5%9C%A8openwrt-lede%E4%B8%8A%E9%83%A8%E7%BD%B2dnscrypt-proxy%E5%BC%BA%E5%8C%96%E5%AE%B6%E5%BA%AD%E7%BD%91%E7%BB%9Cdns%E5%AE%89%E5%85%A8/#disqus_thread">Comments</a></i> <br />
    
    <hr />
    
    <p class="text-muted">
        
            dnscypt-proxy &#43; dnsmasq
        
    </p>
</div>
        
            <div class="list-item ">
    <h3 class="list-title"><a href="https://eternalflame.cn/blog/2018/04/%E7%BE%A4%E6%99%96nas-cloud-sync%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86%E5%8A%9F%E8%83%BD~/">群晖NAS cloud sync的数据加密功能~</a></h3>
    <i class="text-muted"><i class="fas fa-user"></i>Eternal-flame-AD</i> <br />
    <i class="text-muted"><i class="fas fa-clock"></i>Mon, Apr 9, 2018</i> <br />
    <i class="text-muted"><i class="fas fa-shapes"></i><a href="/categories/%e6%8a%80%e6%9c%af">技术&nbsp;</a></i> <br />
    
    <i class="text-muted"><i class="fas fa-comment"></i><a href="https://eternalflame.cn/blog/2018/04/%E7%BE%A4%E6%99%96nas-cloud-sync%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86%E5%8A%9F%E8%83%BD~/#disqus_thread">Comments</a></i> <br />
    
    <hr />
    
    <p class="text-muted">
        
            今天配置了群晖上的Cloud sync，可以把我的NAS上的数据自动备份到百度云，但云端备份使用了RSA加密，可以说很用心~（早知道这么方便本地就直接JBOD了，现在是RAID 1，不过云端多一份备份也是以防万一，譬如整个NAS丢了之类的。。）唯一不太爽的是文件名没有加密，不过也不是很在意这个了
平时可以使用NAS上存储的密钥进行同步，如果出现所有本地备份丢失的情况，可以使用群晖官方提供的解密工具加载自己的私钥解密百度云上的备份~
随李彦宏用数据做什么事情吧= =
        
    </p>
</div>
        
            <div class="list-item ">
    <h3 class="list-title"><a href="https://eternalflame.cn/blog/2018/04/pgp%E7%AE%80%E4%BB%8B4gpg%E9%92%A5%E5%8C%99%E4%B8%B2%E7%9A%84%E7%AE%A1%E7%90%86%E4%B8%8E%E4%BF%A1%E4%BB%BB%E4%BD%93%E7%B3%BB/">【PGP简介】（4）gpg钥匙串的管理与信任体系</a></h3>
    <i class="text-muted"><i class="fas fa-user"></i>Eternal-flame-AD</i> <br />
    <i class="text-muted"><i class="fas fa-clock"></i>Thu, Apr 5, 2018</i> <br />
    <i class="text-muted"><i class="fas fa-shapes"></i><a href="/categories/%e6%8a%80%e6%9c%af">技术&nbsp;</a><a href="/categories/%e6%97%a5%e5%b8%b8">日常&nbsp;</a></i> <br />
    
    <i class="text-muted"><i class="fas fa-comment"></i><a href="https://eternalflame.cn/blog/2018/04/pgp%E7%AE%80%E4%BB%8B4gpg%E9%92%A5%E5%8C%99%E4%B8%B2%E7%9A%84%E7%AE%A1%E7%90%86%E4%B8%8E%E4%BF%A1%E4%BB%BB%E4%BD%93%E7%B3%BB/#disqus_thread">Comments</a></i> <br />
    
    <hr />
    
    <p class="text-muted">
        
            在我们实际使用PGP进行通讯的时候，首先就有一个非常核心的问题：我们究竟如何来管理自己所拥有的密钥呢？ PGP使用了一个钥匙串的体系来管理用户的密钥。下面我用gpg程序演示：
我们可以通过gpg --list-keys命令或者图形界面来查看钥匙串中的公钥，gpg --list-secret-keys来查看私钥：
下面我们来看一个pgp公钥记录（这是我的公钥~）
pub rsa4096 2018-01-19 [SCA] [expires: 2019-01-19] 356982FADCBDDC60DBAD25E84CBBC48C2F2FF36B uid [ultimate] Eternal_flame-AD_extend (extended) &amp;lt;eternal_flame-AD@protonmail.com&amp;gt; uid [ultimate] Eternal_flame-AD(extended) &amp;lt;eternal_flame-AD@protonmail.com&amp;gt; sub rsa4096 2018-01-19 [E] [expires: 2019-01-19] 我们看到，这个公钥有两个用户标识（uid），还有一个子密钥，2018-01-19生效，有效期到2019-01-19，使用的是rsa4096，上面可以看到我的名称和email地址，[ultimate]这个密钥因为被赋予了ultimate级别的信任所以有效性也是绝对可靠的（因为这是我自己的密钥= = 不要给予任何外来的密钥最高信任）
关于信任级别的问题，可以使用gpg edit-keys [uid]进入密钥编辑后查看，我们来看这个密钥（因为是别人的所以我隐藏了指纹和用户标识）：
pub rsa4096/XXXXXXXXXXXXXX created: 2018-02-26 expires: never usage: C trust: never validity: full sub rsa2048/XXXXXXXXXXXX created: 2018-02-26 expires: 2026-02-24 usage: E sub rsa2048/XXXXXXXXXXXXX created: 2018-02-26 expires: 2026-02-24 usage: SA [ full ] (1). XXXXXXX &lt;XXXXXXXXX; 可以看到trust（信任）一栏是never，validity（有效性）是full，这两个有什么区别呢？首先要从validity说起，validity指的是对一个密钥的有效性的说明，是由gpg程序计算出的，而非用户指派，一个密钥要被认为是有效的，就必须满足以下的条件：
 密钥在有效期内 密钥没有被吊销（吊销属于密钥操作，之后会说到） 密钥已经被另一个full级别或ultimate级别trust的密钥签名，或被多个（通常是3个）以上的marginal级别trust的密钥签名  上面的前两个应该比较简洁，第三个就要补充一个知识点了：我之前说到私钥可以给信息签名，这里的签名，不仅仅是对我发出的消息进行签名，还可以对其它的公钥进行签名，以此表明签名者认为该公钥是有效的。例如，你收到了来自朋友的一个公钥，你再将它导入钥匙串之后，gpg程序默认是不认为这个公钥有效的，只有你自己面对面或使用其他可靠方式确认公钥有效性以后，你使用自己的私钥（ultimate级别信任）签名之后，这个公钥才能在钥匙串中被标为有效。而对于full和marginal级别密钥签名的其他密钥，gpg分别有一套处理方法：这里就要说到密钥的trust了，gpg一共有一下五种trust级别，可以在编辑trust时看到：
        
    </p>
</div>
        
            <div class="list-item ">
    <h3 class="list-title"><a href="https://eternalflame.cn/blog/2018/04/_/">-_-#</a></h3>
    <i class="text-muted"><i class="fas fa-user"></i>Eternal-flame-AD</i> <br />
    <i class="text-muted"><i class="fas fa-clock"></i>Wed, Apr 4, 2018</i> <br />
    <i class="text-muted"><i class="fas fa-shapes"></i><a href="/categories/%e6%8a%80%e6%9c%af">技术&nbsp;</a></i> <br />
    
    <i class="text-muted"><i class="fas fa-comment"></i><a href="https://eternalflame.cn/blog/2018/04/_/#disqus_thread">Comments</a></i> <br />
    
    <hr />
    
    <p class="text-muted">
        
            折腾了半天还是没成功开启TLSv1.3
哭唧唧。。。
        
    </p>
</div>
        
            <div class="list-item ">
    <h3 class="list-title"><a href="https://eternalflame.cn/blog/2018/04/%E5%8D%B8%E8%BD%BD%E5%BE%AE%E4%BF%A1%E4%BA%86/">卸载微信了！！</a></h3>
    <i class="text-muted"><i class="fas fa-user"></i>Eternal-flame-AD</i> <br />
    <i class="text-muted"><i class="fas fa-clock"></i>Mon, Apr 2, 2018</i> <br />
    <i class="text-muted"><i class="fas fa-shapes"></i><a href="/categories/python">Python&nbsp;</a><a href="/categories/%e6%8a%80%e6%9c%af">技术&nbsp;</a><a href="/categories/%e6%97%a5%e5%b8%b8">日常&nbsp;</a></i> <br />
    
    <i class="text-muted"><i class="fas fa-comment"></i><a href="https://eternalflame.cn/blog/2018/04/%E5%8D%B8%E8%BD%BD%E5%BE%AE%E4%BF%A1%E4%BA%86/#disqus_thread">Comments</a></i> <br />
    
    <hr />
    
    <p class="text-muted">
        
             因为有一些迫不得已的事情（人←_←）所以还是得收取微信消息
所以写了这个桥（Github），可以使用Riot.im收取和回复微信消息(端到端加密的支持以后看心情了= =，matrix.org用的是https，我还是信任matrix.org的人品的)，服务端挂在服务器上，效果如下（还很简陋后面会优化的= =）：         
神清气爽！！！ 
        
    </p>
</div>
        
            <div class="list-item ">
    <h3 class="list-title"><a href="https://eternalflame.cn/blog/2018/03/pgp%E7%AE%80%E4%BB%8B3pgp%E5%AF%86%E9%92%A5%E5%AF%B9%E7%9A%84%E6%9E%84%E6%88%90%E5%92%8C%E4%BF%A1%E4%BB%BB%E9%80%BB%E8%BE%91/">【PGP简介】（3）PGP密钥对的构成和信任逻辑</a></h3>
    <i class="text-muted"><i class="fas fa-user"></i>Eternal-flame-AD</i> <br />
    <i class="text-muted"><i class="fas fa-clock"></i>Sat, Mar 31, 2018</i> <br />
    <i class="text-muted"><i class="fas fa-shapes"></i><a href="/categories/%e6%8a%80%e6%9c%af">技术&nbsp;</a><a href="/categories/%e6%97%a5%e5%b8%b8">日常&nbsp;</a></i> <br />
    
    <i class="text-muted"><i class="fas fa-comment"></i><a href="https://eternalflame.cn/blog/2018/03/pgp%E7%AE%80%E4%BB%8B3pgp%E5%AF%86%E9%92%A5%E5%AF%B9%E7%9A%84%E6%9E%84%E6%88%90%E5%92%8C%E4%BF%A1%E4%BB%BB%E9%80%BB%E8%BE%91/#disqus_thread">Comments</a></i> <br />
    
    <hr />
    
    <p class="text-muted">
        
            对于一个PGP密钥对，除了公私钥内容之外，它还另外包括了一下信息（这些信息是被这个密钥签名过的，因此只有私钥的所有者能够更改它们）：
 用户标识  用户标识，通常是姓名和电子邮件地址，是用来标识这个PGP密钥的所有者的（注意我这里用的是密钥的所有者 不是用户标识上的姓名 两者的区别我会在下面讲到）  有效期  有效期是密钥的有效时间范围，这个标识是为了保证密钥只在一段时间内有效（比如我的PGP密钥目前有效期是从18年1月19日到19年1月19日），每次使用这个密钥时，PGP程序会核对计算机上的时间和密钥的有效期，如果不在有效期内则会发出警告。设计有效期的目的主要是为了最大程度上减少因为私钥泄露等问题导致的后果，有效期短的密钥需要经常更新（不要忘了，私钥拥有者是可以更改有效期的），推荐每次更新他人的公钥的时候都要验证密钥的来源。  指纹  指纹是对整个密钥的一个hash，由密钥的其他部分经过散列计算而来，主要是用来：  （1）标识这个密钥，在密钥服务器上查找公钥时，常常会使用指纹来搜索（例如你可以在hkp服务器上搜索我的公钥指纹_0x356982FADCBDDC60DBAD25E84CBBC48C2F2FF36B 来获得我完整的公钥_） （2）验证密钥的完整性，比如，今天Alice和Bob见面，它们希望确定之前通过QQ等途径交换的公钥是否就是对方的公钥，他们不必逐字比对完整的公钥（那可能会花费大量时间），而只需要比对密钥指纹，基本就可以确认他们公钥的完整性。   子密钥  子密钥是隶属与这个主密钥的子密钥，可以理解为子密钥用于日常的加密/解密/签名/验证，而主密钥用来操作子密钥（增加子密钥/更改有效期/吊销/……）。一般只有命令行工具才提供比较自由的子密钥操作支持，所以为了通俗一点这里就不介绍具体用法了，引用一个博文   &nbsp;
但是，现在就出现了一个问题，我们假设Alice和Bob使用某种不安全聊天工具交换公钥的时候，Eve（服务器）在中间不仅可以监听，还可以截获/伪造消息，那么，Eve完全有能力自己生成两个密钥对，分别填上Alice和Bob的用户标识，并把假冒的公钥发给Alice和Bob，这样Alice和Bob都会发现自己拿到了用户标识写着对方的公钥（实际上是Eve的公钥，对应的私钥在Eve手中），而当他们再进行通信的时候，他们加密出的所有内容都可以被Eve解密了（例如：Alice把她的消息用自己的私钥签名，之后通过他认为的Bob的公钥加密发出去；Eve截获这个消息，用自己手中的私钥解密（因为Alice手中认为的Bob的公钥其实是Eve生成的 这时Eve就获得消息明文了） 再用自己假冒的Alice的私钥签名 用Bob真正的公钥加密发给Bob；Bob就得到了一条看起来由Alice签名并加密给自己的信息） 这种情况就被称为中间人攻击（MITM），为了确定密钥交换过程中没有中间人的干扰，我们就需要去验证双方收到的公钥是否和发出的相匹配，这一点PGP并不能帮你去做，你只能通过某种安全的渠道（例如见面），逐字核对密钥指纹来确定Alice获得的公钥就是和Bob手中的私钥相对应。在下一篇中我会详细说到PGP是如何处理对公钥的信任的问题的。
        
    </p>
</div>
        
            <div class="list-item ">
    <h3 class="list-title"><a href="https://eternalflame.cn/blog/2018/03/pgp%E7%AE%80%E4%BB%8B2pgp%E7%9A%84%E5%8E%9F%E7%90%86%E7%AE%80%E4%BB%8B%E4%B9%8B%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/">【PGP简介】（2）PGP的原理简介之非对称加密</a></h3>
    <i class="text-muted"><i class="fas fa-user"></i>Eternal-flame-AD</i> <br />
    <i class="text-muted"><i class="fas fa-clock"></i>Fri, Mar 30, 2018</i> <br />
    <i class="text-muted"><i class="fas fa-shapes"></i><a href="/categories/%e6%8a%80%e6%9c%af">技术&nbsp;</a><a href="/categories/%e6%97%a5%e5%b8%b8">日常&nbsp;</a></i> <br />
    
    <i class="text-muted"><i class="fas fa-comment"></i><a href="https://eternalflame.cn/blog/2018/03/pgp%E7%AE%80%E4%BB%8B2pgp%E7%9A%84%E5%8E%9F%E7%90%86%E7%AE%80%E4%BB%8B%E4%B9%8B%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/#disqus_thread">Comments</a></i> <br />
    
    <hr />
    
    <p class="text-muted">
        
            这篇文章主要讨论的是PGP究竟是如何工作的~小透明会尽量简洁通俗地讲清楚究竟PGP能够给我们提供什么，它是如何保护我们的隐私的~
 首先，在介绍具体实现之前，先简要介绍一些核心的概念~ PGP使用了一个非常核心的加密机制——非对称加密，它和我们平常所说的加密有所不同： 平常我们所说的“加密”，是指对称加密，例如我通过某种算法，使用一个密钥（密码）加密明文，获得的密文发送给对方后，对方也使用这个密钥逆转这个加密过程，获得我最初加密的明文。 “非对称加密”（也称“公钥加密”）有所不同的是，非对称加密一个流程一共使用了两个密钥：公钥和私钥（一对公私钥合称一个密钥对，之后的文字会使用这个名词简化语言），故名思议，公钥就是“公开的密钥”，而私钥是自己保存，不给别人的！！非对称加密的算法有一个特性——一个密钥对中，经过公钥加密的明文只能使用私钥解密，经过私钥加密的明文需要使用公钥解密，有没有感觉到“非对称”这个词的意义了？如果还是有点没有懂，结合下面这张图解释一下：  现在Bob希望向Alice发送一个信息（“Hello Alice!”），于是Bob要求Alice将她的公钥发送给他，Bob获得这个公钥后将消息通过这个公钥加密之后将密文发回给Alice，Alice可以通过自己的私钥将密文解密为明文，这样就完成了一次非对称加密保护的信息交换。你可能已经发现了非对称加密的一个最大的优点：在整个过程中这条消息的解密密钥（Alice的私钥）在对话中完全没有被交换，也就是说，即使有一个人（我们叫她Eve PS:ABE这三个人就是我们的小明，小红和小亮，之后会经常看到的哈哈哈哈哈哈哈）截获了两个人的整个通话内容，在加密算法是安全的情况下，Eve也无法获得任何消息明文，因为她只能截获密文和Alice的公钥，这是对称加密所不能做到的（对称加密无法避免密钥信息的交换）。 除了上述提到的这个优点，非对称加密还有一个不可比拟的优势， 我们设想这样一种情形：一个公司里有100个人，现在这100个人想建立一个系统，让每两个人之间都能够安全的交换信息。如果使用对称加密手段：方法简单粗暴，每两个人之间使用一个密钥，整个系统一共需要100*99&frasl;2=4950个密钥，而且需要的密钥数和人数并非呈线性，一万人就需要五千万个密钥。而使用非对称加密手段时，每个人只要自己生成一个密钥对，公开自己的公钥即可，整个系统只需要100个密钥对 然而，非对称加密也有一个最大的缺点，一个字：慢。不像通常是通过位运算和矩阵的运算实现的对称加密算法，非对称算法涉及大量随机数的生成和很大数字的运算，因此加密一段内容的开销比对称算法大得多（加密相同长度的数据消耗的cpu时间五十倍甚至更多），为了补偿性能上巨大的差异，通常在使用非对称算法加密信息时，加密者会先生成一个随机的密钥，用这个密钥使用对称算法加密明文后，将这个密钥（通常是固定长度，比消息短的多）使用非对称算法加密后放在密文末尾，而接受者先使用自己的私钥解密消息密钥，再使用这个密钥解密消息，这样就很大程度上减少了因使用非对称算法导致的性能损失（openpgp也使用了这种策略） 当然近几年也有新的算法（例如椭圆曲线ECC很大程度改进了性能） 除了加密消息之外，非对称加密算法还有一个很重要的用途：数字签名 这一点其实很多人并不是很能理解，认为有的时候连手写签名都能造假，凭什么我就应该相信一个数字签名呢？下面我简单介绍一下为什么数字签名具有可靠性 数字签名主要证明的是两点：1. 消息的发出者 2.消息在传输过程中没有经过修改。我们通过下面这个实例来看看数字签名是如何实现的： 仍然是Alice希望给Bob发送一个邮件：&#8221;Meet me at 3 P.M&#8221;，这次Alice将这个消息通过某个散列函数（例如SHA512 你可能听说过MD5，他们都是散列函数，是一个可以将任意长度信息成一个固定长度的信息的函数 可以理解为生成了消息的&#8221;指纹&#8221;），Alice希望证实这个消息由她发出并且在传输过程中没有经过篡改，因此她使用自己的私钥加密这个消息&#8221;指纹&#8221;，将整个消息和指纹的加密结果一起发给Bob，而Bob接收到这个消息之后，用Alice的公钥解密出消息指纹，然后和自己计算的收到的消息的指纹进行比对，如果一致，那么就证明了这条消息的来源和完整性——因为，_只有拥有Alice私钥的人才能够加密出可以被Alice的公钥解密的信息_（这里有点绕需要理解一下QWQ 其实就是和加密相反，加密是公钥加密私钥解密 签名是私钥加密公钥解密） 当然在这个过程中，如果中间人Eve想篡改消息内容，除了获得Alice的私钥之外，还有一个方法就是构造一个新的信息并且和原信息具有相同的&#8221;指纹&#8221;，然而要获得一个指纹和原消息指纹相同的消息，这个操作所需要花费的代价是巨大的（对于SHA512，平均需要花费2^511次尝试） 可能你会说，数字签名确实很tricky，但我用不着啊，其实数字签名的应用其实我们每天都在使用，例如你在访问这个博客的时候、你在网上银行交易的时候，服务器都会提供一个证书（其中就包含了一个公钥），并且将自己发送的所有网页信息经过数字签名发送给你，而你的浏览器会对这个数字签名进行校验（校验的机制我会另外写一篇blog），如果浏览器认为这个消息可信，你就会在地址栏上看到那个绿色的小锁啦！  
        
    </p>
</div>
        
            <div class="list-item ">
    <h3 class="list-title"><a href="https://eternalflame.cn/blog/2018/03/pgp%E7%AE%80%E4%BB%8B1-phil-zimmermann-creator-of-pgp-phil-zimmermannpgp%E4%B9%8B%E7%88%B6/">【PGP简介】（1） Phil Zimmermann – Creator of PGP | Phil Zimmermann——PGP之父</a></h3>
    <i class="text-muted"><i class="fas fa-user"></i>Eternal-flame-AD</i> <br />
    <i class="text-muted"><i class="fas fa-clock"></i>Thu, Mar 29, 2018</i> <br />
    <i class="text-muted"><i class="fas fa-shapes"></i><a href="/categories/%e5%ad%a6%e4%b9%a0">学习&nbsp;</a><a href="/categories/%e6%8a%80%e6%9c%af">技术&nbsp;</a><a href="/categories/%e6%97%a5%e5%b8%b8">日常&nbsp;</a></i> <br />
    
    <i class="text-muted"><i class="fas fa-comment"></i><a href="https://eternalflame.cn/blog/2018/03/pgp%E7%AE%80%E4%BB%8B1-phil-zimmermann-creator-of-pgp-phil-zimmermannpgp%E4%B9%8B%E7%88%B6/#disqus_thread">Comments</a></i> <br />
    
    <hr />
    
    <p class="text-muted">
        
            打算开天坑啦~这次打算开一个PGP简介的系列，会从简介和历史讲起，之后会介绍一些常用PGP工具的使用，其中具体技术实现上只打算触及原理介绍和使用方法，不打算涉及过于复杂的细节上的实现，适合用来拉人入坑~

Phil Zimmermann，Pretty Good Privacy(PGP)软件的开创者，个人网站：（中文版 英文版）。他在1991年开发了PGP软件的第一个版本，据说这样一个名字是受到一家名为“Ralph&#8217;s Pretty Good Grocery”的果蔬店的启发而来，当时Phil Zimmermann作为一名反核人士，打算利用自己开发的PGP来保证同样反核的人们能够在互联网上安全的交换信息。因为这个目的，所以Phil Zimmermann没有打算通过售卖PGP的授权获得任何利润，而是直接将PGP及其源代码发布在了各大BBS上，让互联网上的每个人都有权使用、检查和修改其中的代码。
Phil Zimmermann的PGP很快便引起了极大的反响，也有很多其它国家的人们开始使用PGP软件，然而这一事件却违反了当时美国出口法令：在当时，美国规定超过40位的加密算法都是禁止出口的，而PGP使用的加密算法最低为128位，因此Phil Zimmermann当时收到了长达三年的刑事调查，在调查期间，Phil Zimmermann使用了非常有趣的方法规避这样一个问题：他将所有PGP的源码出版成了书籍，这样每个人只要购买这本书，将书上的代码输入到计算机里，就可以编译出PGP软件，而Phil传播PGP的代码也因为这本书的出版，变成了收到言论自由保护的行为。三年之后，当局放弃了对Phil的指控。
当局放弃对Phil的指控后，Phil拍的照片= = 2010年，Symantec购买了PGP的授权，将PGP应用于自己的加密工具(Gateway Email Encryption)中，Symantec的PGP工具的源代码依然开放（链接），同时另一个开源分支（和Symantec无关）OpenPGP也在积极收到维护，小透明写的这组文章主要是针对OpenPGP进行介绍~
        
    </p>
</div>
        
            <div class="list-item ">
    <h3 class="list-title"><a href="https://eternalflame.cn/blog/2018/03/python%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E5%BA%A6%E6%8B%B7%E8%B4%9D/">Python对象的拷贝和深度拷贝</a></h3>
    <i class="text-muted"><i class="fas fa-user"></i>Eternal-flame-AD</i> <br />
    <i class="text-muted"><i class="fas fa-clock"></i>Tue, Mar 27, 2018</i> <br />
    <i class="text-muted"><i class="fas fa-shapes"></i><a href="/categories/python">Python&nbsp;</a><a href="/categories/%e6%8a%80%e6%9c%af">技术&nbsp;</a></i> <br />
    <i class="text-muted"><i class="fas fa-tags"></i><a href="/tags/python">Python&nbsp;</a></i>
    <i class="text-muted"><i class="fas fa-comment"></i><a href="https://eternalflame.cn/blog/2018/03/python%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E5%BA%A6%E6%8B%B7%E8%B4%9D/#disqus_thread">Comments</a></i> <br />
    
    <hr />
    
    <p class="text-muted">
        
            Python语言中，对象的传递默认是引用传递，如果需要创建一个对象的拷贝可以使用copy库：
import copy list1=[&#39;1&#39;] list2=copy.copy(list1) list2.append(&#39;2&#39;) print(list1) #[&#39;1&#39;] 不过,copy.copy(x)方法是浅层拷贝（即如果list1是一个包含list的list，那么它包含的list仍然会被以引用形式传递）:
import copy list1=[[&#39;1&#39;]] list2=copy.copy(list1) list2[0].append(&#39;2&#39;) print(list1) #[[&#39;1&#39;,&#39;2&#39;]] 而copy.deepcopy(x)方法即为深度拷贝，会将对象中包含的所有对象也进行拷贝：
import copy list1=[[&#39;1&#39;]] list2=copy.deepcopy(list1) list2[0].append(&#39;2&#39;) print(list1) #[[&#39;1&#39;]] 
        
    </p>
</div>
        
            <div class="list-item ">
    <h3 class="list-title"><a href="https://eternalflame.cn/blog/2018/03/%E8%AE%B0openssl%E7%89%88%E6%9C%AC%E5%86%B2%E7%AA%81%E5%AF%BC%E8%87%B4php-fpm%E5%8F%8D%E5%A4%8D%E5%B4%A9%E6%BA%83/">记openssl版本冲突导致PHP-FPM反复崩溃</a></h3>
    <i class="text-muted"><i class="fas fa-user"></i>Eternal-flame-AD</i> <br />
    <i class="text-muted"><i class="fas fa-clock"></i>Sun, Mar 25, 2018</i> <br />
    <i class="text-muted"><i class="fas fa-shapes"></i><a href="/categories/php">PHP&nbsp;</a><a href="/categories/%e6%8a%80%e6%9c%af">技术&nbsp;</a><a href="/categories/%e6%97%a5%e5%b8%b8">日常&nbsp;</a></i> <br />
    
    <i class="text-muted"><i class="fas fa-comment"></i><a href="https://eternalflame.cn/blog/2018/03/%E8%AE%B0openssl%E7%89%88%E6%9C%AC%E5%86%B2%E7%AA%81%E5%AF%BC%E8%87%B4php-fpm%E5%8F%8D%E5%A4%8D%E5%B4%A9%E6%BA%83/#disqus_thread">Comments</a></i> <br />
    
    <hr />
    
    <p class="text-muted">
        
            <p>之前在部署服务器PHP-FPM时，发现web应用经常会出现502情况，具体有以下表现：</p>
        
    </p>
</div>
        
            <div class="list-item ">
    <h3 class="list-title"><a href="https://eternalflame.cn/blog/2018/03/python%E4%BD%BF%E7%94%A8colorama%E5%AE%9E%E7%8E%B0%E6%8E%A7%E5%88%B6%E5%8F%B0%E5%BD%A9%E8%89%B2%E6%96%87%E5%AD%97%E8%BE%93%E5%87%BA/">python使用colorama实现控制台彩色文字输出</a></h3>
    <i class="text-muted"><i class="fas fa-user"></i>Eternal-flame-AD</i> <br />
    <i class="text-muted"><i class="fas fa-clock"></i>Sat, Mar 24, 2018</i> <br />
    <i class="text-muted"><i class="fas fa-shapes"></i><a href="/categories/python">Python&nbsp;</a><a href="/categories/%e6%8a%80%e6%9c%af">技术&nbsp;</a><a href="/categories/%e6%97%a5%e5%b8%b8">日常&nbsp;</a></i> <br />
    <i class="text-muted"><i class="fas fa-tags"></i><a href="/tags/python">Python&nbsp;</a><a href="/tags/%e6%8e%a7%e5%88%b6%e5%8f%b0">控制台&nbsp;</a></i>
    <i class="text-muted"><i class="fas fa-comment"></i><a href="https://eternalflame.cn/blog/2018/03/python%E4%BD%BF%E7%94%A8colorama%E5%AE%9E%E7%8E%B0%E6%8E%A7%E5%88%B6%E5%8F%B0%E5%BD%A9%E8%89%B2%E6%96%87%E5%AD%97%E8%BE%93%E5%87%BA/#disqus_thread">Comments</a></i> <br />
    
    <hr />
    
        <img src="Python_logo_and_wordmark.svg_.png" class="img-fluid" />
    
    <p class="text-muted">
        
            <p>为了之后写代码方便，打算写一个<a href="https://github.com/eternal-flame-AD/eflog">日志模块</a>，需要实现在控制台上展示不同颜色的文字区分日志紧急度，于是发现了这个colorama模块（<a href="https://github.com/tartley/colorama">Github</a>）~</p>

<p>colorama可以实现跨平台的前/背景彩色输出，同时还可以加入调暗等文字效果，十分方便</p>
        
    </p>
</div>
        
    </div>
    </body>
</html>