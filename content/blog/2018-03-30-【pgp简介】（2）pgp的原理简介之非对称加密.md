---
title: 【PGP简介】（2）PGP的原理简介之非对称加密
author: Eternal-flame-AD
layout: post
identifier: f86fcf906507beac926ff5101ce773ac
date: 2018-03-30T04:14:26+00:00
categories:
  - 技术
  - 日常

---
这篇文章主要讨论的是PGP究竟是如何工作的~小透明会尽量简洁通俗地讲清楚究竟PGP能够给我们提供什么，它是如何保护我们的隐私的~

  * 首先，在介绍具体实现之前，先简要介绍一些核心的概念~ PGP使用了一个非常核心的加密机制——非对称加密，它和我们平常所说的加密有所不同：
  * 平常我们所说的“加密”，是指对称加密，例如我通过某种算法，使用一个密钥（密码）加密明文，获得的密文发送给对方后，对方也使用这个密钥逆转这个加密过程，获得我最初加密的明文。
  * “非对称加密”（也称“公钥加密”）有所不同的是，非对称加密一个流程一共使用了两个密钥：公钥和私钥（一对公私钥合称一个密钥对，之后的文字会使用这个名词简化语言），故名思议，公钥就是“公开的密钥”，而私钥是自己保存，不给别人的！！非对称加密的算法有一个特性——一个密钥对中，**经过公钥加密的明文只能使用私钥解密，经过私钥加密的明文需要使用公钥解密**，有没有感觉到“非对称”这个词的意义了？如果还是有点没有懂，结合下面这张图解释一下：
    ![](/images/525px-Public_key_encryption.svg_.png)
  * 现在Bob希望向Alice发送一个信息（“Hello Alice!”），于是Bob要求Alice将她的公钥发送给他，Bob获得这个公钥后将消息通过这个公钥加密之后将密文发回给Alice，Alice可以通过自己的私钥将密文解密为明文，这样就完成了一次非对称加密保护的信息交换。你可能已经发现了非对称加密的一个最大的优点：在整个过程中这条消息的解密密钥（Alice的私钥）在对话中完全没有被交换，也就是说，即使有一个人（我们叫她Eve PS:ABE这三个人就是我们的小明，小红和小亮，之后会经常看到的哈哈哈哈哈哈哈）截获了两个人的整个通话内容，在加密算法是安全的情况下，Eve也无法获得任何消息明文，因为她只能截获密文和Alice的公钥，这是对称加密所不能做到的（对称加密无法避免密钥信息的交换）。
  * 除了上述提到的这个优点，非对称加密还有一个不可比拟的优势， 我们设想这样一种情形：一个公司里有100个人，现在这100个人想建立一个系统，让每两个人之间都能够安全的交换信息。如果使用对称加密手段：方法简单粗暴，每两个人之间使用一个密钥，整个系统一共需要100*99/2=4950个密钥，而且需要的密钥数和人数并非呈线性，一万人就需要五千万个密钥。而使用非对称加密手段时，每个人只要自己生成一个密钥对，公开自己的公钥即可，整个系统只需要100个密钥对
  * 然而，非对称加密也有一个最大的缺点，一个字：慢。不像通常是通过位运算和矩阵的运算实现的对称加密算法，非对称算法涉及大量随机数的生成和很大数字的运算，因此加密一段内容的开销比对称算法大得多（加密相同长度的数据消耗的cpu时间五十倍甚至更多），为了补偿性能上巨大的差异，通常在使用非对称算法加密信息时，加密者会先生成一个随机的密钥，用这个密钥使用对称算法加密明文后，将这个密钥（通常是固定长度，比消息短的多）使用非对称算法加密后放在密文末尾，而接受者先使用自己的私钥解密消息密钥，再使用这个密钥解密消息，这样就很大程度上减少了因使用非对称算法导致的性能损失（openpgp也使用了这种策略） 当然近几年也有新的算法（例如椭圆曲线ECC很大程度改进了性能）
  * 除了加密消息之外，非对称加密算法还有一个很重要的用途：数字签名 这一点其实很多人并不是很能理解，认为有的时候连手写签名都能造假，凭什么我就应该相信一个数字签名呢？下面我简单介绍一下为什么数字签名具有可靠性
  * 数字签名主要证明的是两点：1. 消息的发出者 2.消息在传输过程中没有经过修改。我们通过下面这个实例来看看数字签名是如何实现的：
  * 仍然是Alice希望给Bob发送一个邮件：&#8221;Meet me at 3 P.M&#8221;，这次Alice将这个消息通过某个散列函数（例如SHA512 你可能听说过MD5，他们都是散列函数，是一个可以将任意长度信息成一个固定长度的信息的函数 可以理解为生成了消息的&#8221;指纹&#8221;），Alice希望证实这个消息由她发出并且在传输过程中没有经过篡改，因此她使用自己的**私钥**加密这个消息&#8221;指纹&#8221;，将整个消息和指纹的加密结果一起发给Bob，而Bob接收到这个消息之后，用Alice的**公钥**解密出消息指纹，然后和自己计算的收到的消息的指纹进行比对，如果一致，那么就证明了这条消息的来源和完整性——因为，_只有拥有Alice私钥的人才能够加密出可以被Alice的公钥解密的信息_（这里有点绕需要理解一下QWQ 其实就是和加密相反，加密是**公钥**加密**私钥**解密 签名是**私钥**加密**公钥**解密）
  * 当然在这个过程中，如果中间人Eve想篡改消息内容，除了获得Alice的私钥之外，还有一个方法就是**构造一个新的信息**并且和原信息具有相同的&#8221;指纹&#8221;，然而要获得一个指纹和原消息指纹相同的消息，这个操作所需要花费的代价是巨大的（对于SHA512，平均需要花费2^511次尝试）
  * 可能你会说，数字签名确实很tricky，但我用不着啊，其实数字签名的应用其实我们每天都在使用，例如你在访问这个博客的时候、你在网上银行交易的时候，服务器都会提供一个证书（其中就包含了一个公钥），并且将自己发送的所有网页信息经过数字签名发送给你，而你的浏览器会对这个数字签名进行校验（校验的机制我会另外写一篇blog），如果浏览器认为这个消息可信，你就会在地址栏上看到那个绿色的小锁啦！